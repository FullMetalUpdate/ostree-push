#!/usr/bin/python3

from __future__ import print_function

from argparse import ArgumentParser
from enum import Enum
from gi.repository import GLib, Gio, OSTree
from pushlib import *
import subprocess
import sys
from urllib.parse import urlparse

class OSTreePusher(object):
    def __init__(self, repopath, remotepath, branches=[]):
        self.repopath = repopath
        self.remotepath = remotepath

        self.remote_host = None
        self.remote_user = None
        self.remote_repo = None
        self.remote_port = None
        self._set_remote_args()

        if self.repopath is None:
            self.repo = OSTree.Repo.new_default()
        else:
            self.repo = OSTree.Repo.new(Gio.File.new_for_path(self.repopath))
        self.repo.open(None)

        # Enumerate branches to push
        if len(branches) == 0:
            _, self.refs = self.repo.list_refs(None, None)
        else:
            self.refs = {}
            for branch in branches:
                _, rev = self.repo.resolve_rev(branch, False)
                self.refs[branch] = rev

        # Start ssh
        ssh_cmd = ['ssh']
        if self.remote_user:
            ssh_cmd += ['-l', self.remote_user]
        if self.remote_port:
            ssh_cmd += ['-p', self.remote_port]
        ssh_cmd += [self.remote_host, 'ostree-receive',
                    '--repo=%s' % self.remote_path]
        #print('Executing', *ssh_cmd)
        self.ssh = subprocess.Popen(ssh_cmd, stdin=subprocess.PIPE,
                                    stdout=subprocess.PIPE)

        self.writer = PushMessageWriter(self.ssh.stdin)
        self.reader = PushMessageReader(self.ssh.stdout)

    def _set_remote_args(self):
        url = urlparse(self.remotepath)
        if url.netloc:
            if url.scheme != 'ssh':
                raise PushException('Only URL scheme ssh is allowed, '
                                    'not "%s"' % url.scheme)
            self.remote_host = url.hostname
            self.remote_user = url.username
            self.remote_repo = url.path
            self.remote_port = url.port
        else:
            # Scp/git style remote (user@hostname:path)
            self.remote_port = None
            parts = self.remotepath.split('@', 1)
            if len(parts) > 1:
                self.remote_user = parts[0]
                remainder = parts[1]
            else:
                self.remote_user = None
                remainder = parts[0]
            parts = remainder.split(':', 1)
            if len(parts) != 2:
                raise PushException('Remote repository "%s" does not '
                                    'contain a hostname and path separated '
                                    'by ":"' % self.remotepath)
            self.remote_host, self.remote_path = parts

    def needed_commits(self, remote, local, needed):
        parent = local
        if remote == '0' * 64:
            # Nonexistent remote branch, use None for convenience
            remote = None
        while parent != remote:
            needed.add(parent)
            _, commit = self.repo.load_variant_if_exists(OSTree.ObjectType.COMMIT,
                                                         parent)
            if commit is None:
                raise PushException('Shallow history from commit %s does '
                                    'not contain remote commit %s'
                                    %(local, remote))
            parent = OSTree.commit_get_parent(commit)
            if parent is None:
                break
        if remote is not None and parent != remote:
            raise PushException('Remote commit %s not descendent of '
                                'commit %s' %(remote, local))

    def needed_objects(self, commits):
        objects = set()
        for rev in commits:
            _, reachable = self.repo.traverse_commit(rev, 0, None)
            for obj in reachable:
                objname = OSTree.object_to_string(obj[0], obj[1])
                if obj[1] == OSTree.ObjectType.FILE:
                    # Make this a filez since we're archive-z2
                    objname += 'z'
                elif obj[1] == OSTree.ObjectType.COMMIT:
                    # Add in detached metadata
                    metaobj = objname + 'meta'
                    metapath = ostree_object_path(self.repo, metaobj)
                    if os.path.exists(metapath):
                        objects.add(metaobj)

                    # Add in Endless compat files
                    for suffix in ['sig', 'sizes2']:
                        metaobj = obj[0] + '.' + suffix
                        metapath = ostree_object_path(self.repo, metaobj)
                        if os.path.exists(metapath):
                            objects.add(metaobj)
                objects.add(objname)
        return objects

    def close(self):
        self.ssh.stdin.close()
        return self.ssh.wait()

    def run(self):
        remote_refs = {}
        update_refs = {}

        # Receive remote info
        args = self.reader.receive_info()
        remote_mode = args['mode']
        if remote_mode != OSTree.RepoMode.ARCHIVE_Z2:
            raise PushException('Can only push to archive-z2 repos')
        remote_refs = args['refs']
        for branch, rev in self.refs.items():
            remote_rev = remote_refs.get(branch, '0' * 64)
            if rev != remote_rev:
                update_refs[branch] = remote_rev, rev
        if len(update_refs) == 0:
            print('Nothing to update')
            self.writer.send_done()
            return self.close()

        # Send update command
        self.writer.send_update(update_refs)

        # Receive status
        args = self.reader.receive_status()
        if not args['result']:
            raise PushException(args['message'])

        # Collect commits and objects to push
        commits = set()
        for branch, revs in update_refs.items():
            print('Updating', branch, revs[0], 'to', revs[1])
            needed = self.needed_commits(revs[0], revs[1], commits)
        objects = self.needed_objects(commits)
        print('Will send objects:')
        print('\n'.join(list(objects)))

        # Tell the receiver to exit
        self.writer.send_done()

        return self.close()

if __name__ == '__main__':
    aparser = ArgumentParser(description='Execute commands through ssh')
    aparser.add_argument('--repo', help='local repository')
    aparser.add_argument('remote', help='remote repository')
    aparser.add_argument('branch', nargs='*', help='branches to push')
    args = aparser.parse_args()

    pusher = OSTreePusher(args.repo, args.remote, args.branch)
    exit(pusher.run())
